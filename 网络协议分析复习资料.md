#为什么TCP需要进行三次握手#
##简单介绍TCP三次握手##
第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)
，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。

#三次握手的原因#
三次握手的最主要目的是保证连接是双工的，可靠更多的是通过重传机制来保证的。

#UDP编程框架#
<pre>
#include &lt;winsock2.h>
#include &lt;stdio.h>

#define PORT 1355
#define LEN 256

int main ()
{
	WSADATA wsaData;
	SOCKET ss;
	sockaddr_in in,from;
	char buf[LEN] = {0};
	int namelen, len;

	WSAStartup(MAKEWORD(2,2), &wsaData);
	ss = socket(AF_INET, SOCK_DGRAM, 0);
	memset (&in, 0, sizeof(in));
	in.sin_family = AF_INET;
	in.sin_port = htons(PORT);
	in.sin_addr.s_addr = inet_addr("127.0.0.1");
	bind(ss, (sockaddr *)&in, sizeof(in));
	memset (&from, 0, sizeof(from));
	namelen = sizeof(from);

	/* recv buf */
	len = recvfrom(ss, buf, LEN, 0, (sockaddr *)&from, &namelen);
	printf ("Recv:%s\n", buf);
	/* send buf */
	sendto(ss, buf, sizeof(buf), 0, (sockaddr *)&from, sizeof(from));

	WSACleanup();
}


</pre>